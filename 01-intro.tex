\chapter{Introduction}

\tdi{CITATIONS!!!}

\tdi{Intro, motivation, goals}

\chapter{Cryptographic background}

\tdi{Intro}

\section{Cryptographic primitives}

The term \emph{cryptographic primitives} is used to refer to frequently used algorithms that serve as building blocks for more complex cryptographic protocols or systems.
They are designed to perform a single, very specific task.
This limitation of scope allows them to be simple, reliable and secure.

Each cryptographic primitive provides some (usually quite low-level) function and gives guarantees about it's security, provided some specified requirements are satisfied by the user. 
For example, a symmetric cipher might guarantee no attack faster than brute force exists, provided the same IV (\emph{initialization vector} -- see later) is never used twice.

There are many well known cryptographic primitives that have been in use for many years and have been the targets of many researchers for just as long.
Using them when designing any cryptographic applications makes this process less error prone, as all the designer has to do is keep the requirements satisfied instead of having to invent new primitives and then prove their security.

The most common primitives, many of which will be important for us in this work, are:
\begin{description}
\item[One-way hash functions] such as \emph{MD5}, \emph{SHA-1} or \emph{KECCAK}. \\
These produce a short \emph{digest} from arbitrarily long input message, however the reverse is hard to compute.
\item[Symmetric block and stream ciphers] such as \emph{AES} or \emph{Trivium}. \\
These encrypt and decrypt messages into \emph{ciphertext} and back using a \emph{secret key} which must be known for both steps.
\item[Asymmetric ciphers] such as \emph{RSA}. \\ 
These also provide encryption and decryption, however the two processes use two different keys, one of which can be publicly distributed.
\item[Digital signatures] such as \emph{DSA}, \emph{ElGamal} or \emph{Rabin}. \\
These can be used as a digital equivalent of signatures, proving the authorship and authenticity of a message.
\item[And many others] such as \emph{commitment schemes}, \emph{authentication} etc. which we will not be a focus of this work.
\end{description}

\section{Hash functions}
The most important cryptographic primitive for our purposes are \emph{hash functions}.
These are designed to reduce a long input \emph{message} into a fixed-length \emph{digest} (short from \emph{message digest}, also called \emph{hash}).
These functions should be easy to compute this way but infeasible\footnote{When we call a problem \emph{infeasible} we mean the computation should take exponential time, and thus is not practical for sufficient input sizes.} when going the other way -- from digest to message.

Formally, hash function $h$ is a function $h: X \to Y$ where $X$ is the (unbounded) set of inputs (messages) and $h(x) \in Y = \{0, 1\}^n$ is an n-bit long output digest.
The properties which we require this function to have are:

\begin{description}
\item[Pre-image resistance] \hfill \\
Given a hash $h$ it is hard to find a message $m$ such that $h(m) = h$.
\item[Second pre-image resistance] \hfill \\
Given a message $m_1$ it is hard to find a message $m_2$ such that $h(m_1) = h(m_2)$ and $m_1 \neq m_2$.
\item[Collision resistance] \hfill \\
It is hard to find messages $m_1, m_2$ such that $h(m_1) = h(m_2)$ and $m_1 \neq m_2$.
\end{description}

It is easy to see that when a hash function lacks one of these properties it also lacks all the following ones.
For example, if it's not second pre-image resistant it will also not be collision resistant.

Another useful and desirable property is the \emph{avalanche effect} -- changing a small part of the input message (for example, flipping a single bit) will have a large and unpredictable effect on the output digest (for example, half of the output bits flip).
For example, when we hash several close variations of the title of this thesis using \emph{SHA-1} we will get obviously different outputs:

\begin{tabular}{r l}
\texttt{Use of SAT Solvers in Cryptanalysis} & \texttt{2a39 79ea 37d6 4e4d 86eb} \\
& \texttt{fa77 3bb7 d027 3445 9e8f} \\
\texttt{Use of SAT-Solvers in Cryptanalysis} & \texttt{9cdb e658 e1a0 5454 ef0a}\\
& \texttt{0aae 7b07 f800 99b6 a2d2} \\
\texttt{Use of SAT-Solvers in cryptanalysis} & \texttt{83c4 3541 804d 3695 de67}\\
& \texttt{d9e5 064d 3db4 6113 4c22} \\
\texttt{Use of SAT Solvers in cryptanalysis} & \texttt{8753 1b8f fbf3 11dd ecf7} \\
& \texttt{7038 51ab a9d9 95f5 0fed}
\end{tabular}

Even though every two successive lines only differ in a single character (the dash in \emph{SAT-Solvers} and the capitalization of \emph{cryptanalysis}), the hashes are obviously different even on first glance.
This is useful for example when hash functions are used as \emph{checksums} for files published on the Internet.
The goal is to provide a short digest of a large file to verify that the downloaded file is identical to the authors' version -- the differences can arise from either malicious tampering or accidental network transmission errors.
After a user downloads this file they can compute the digest locally and verify that it matches the one provided.
Even if this verification is only done as a casual comparison by the user the avalanche effect will make the differences easy to spot.

\subsection{Merkle-Damg\aa rd construction}

Our definition of hash function requires that it will accept inputs of arbitrary length.
This is however harder to design than a function which operates on fixed size \emph{blocks}.
The Merkle-Damg\aa rd construction is a way to extend this fixed size function (called \emph{compression function}) into a proper hash function while preserving collision resistance.

Formally, given a compression function $f: \{0,1\}^{n+r+1} \to \{0,1\}^n$ with $n,r \ge 1$ we will create a hash function $h: \{0,1\}^* \to \{0,1\}^n$ like this: Take the input $x$ of length $l$ and split it into $t$ blocks of length $r$ each.
\tdi{padding}

Then we define $h(x) := H_{t+1}$ with (the $||$ operation represents concatenation of binary strings)
\begin{align*}
H_1 &= f(0^{n+1} ~||~ x_1) \\
H_i &= f_i(H_{i-1} ~||~ 1 ~||~ x_i)
\end{align*}

The following theorem shows that this construction preserves the collision resistance of the compression function $f$:

\begin{theorem}
If the compression function $f$ is collision resistant then also the hash function $h$ constructed as above is also collision resistant.
\end{theorem}
\begin{proof}
Suppose we can effectively find a collision in $h$, that is a pair $x \neq x'$ such that $h(x) = h(x')$.
Let $|x| = \ell$ and $|x'| = \ell'$.
Also let $t$ and $t'$ be the number of blocks after padding and splitting the inputs $x$ and $x'$ respectively.
\\

First let's consider the case when $t = t'$.
This means that $f(H_t ~||~ 1 ~||~ x_{t+1}) = f(H'_t ~||~ 1 ~||~ x'_{t+1})$. 
If the arguments are different we have found a collision in $f$ which is contradiction with the assumption that $f$ is collision resistant.
If they are equal that means $x_{t+1} = x'_{t+1}$ and $f(H_{t-1} ~||~ 1 ~||~ x_t) = f(H'_{t-1} ~||~ 1 ~||~ x'_t)$.
Again, if the arguments are different we have a collision in $f$ so we will only consider the case when they are equal.

Repeating this argument $t$ times we will get $f(0^{n+1} ~||~ x_1) = f(0^{n+1} ~||~ x'_1)$.
Again, only considering the case when the argument are equal we get that $\forall i \in \{1,\ldots,n\}: x_i = x'_i$ which implies $x = x'$ and this is a contradiction with the assumption the inputs are different.
\\

Now let's consider the case (without loss of generality) when $t < t'$.
Using the previous argument and repeating it $t$ times we will get the equality $f(0^{n+1} ~||~ x_1) = f(H_{t'-t} ~||~ 1 ~||~ x'_{t'-t+1})$.
The $n+1$-th bit of the inputs is $0$ on the left side and $1$ on the right side, which means we have found different inputs for $f$ that produce a collision, again a contradiction with the assumption that $f$ is collision resistant. 
\end{proof}

Many common and widely used hash functions are based on this construction, however the details of the construction can be modified.
These include \emph{SHA-1} and the \emph{SHA-2} family (consisting of \emph{SHA-256}, \emph{SHA-512} and others).
To provide an example of a real hash function but also to serve as a basis for further discussion and analysis we will now describe these hash functions in detail.

\subsubsection{SHA-1}

\emph{SHA-1}, short for \emph{Secure Hash Algorithm} is a hash function designed by the \emph{NSA} (\emph{National Security Agency}) and published in 1995.
It produces output digest of $160$ bits, processing the input in blocks of $512$ bits.
The first block is always the same, a constant \emph{initialization vector} (IV).
The output of the last round of compression function (when processing the last input block) is the final output digest.

\tdi{block processing/padding + IV + construction}

The compression function $f$ itself is defined as follows, where $H$ are the parts of previous round's output and $M$ are the parts of
the current input block, all $32$ bits in length:
\[
f(H_0 ~||~ \cdots ~||~ H_4, ~ M_0 ~||~ \cdots ~||~ M_{15}) = \dots
\]
\tdi{SHA-1 details}

\subsubsection{SHA-2}
\tdi{SHA2 family}

\subsection{Sponge construction}
Another approach to constructing hash functions is the \emph{sponge} construction, which is used for example by the \emph{SHA-3} family.
The idea is to use an internal hidden stat that will be initialized by the input message and then used to produce the output digest.

Let's have an input $x$ split into several blocks $x_1, \dots, x_t$, each of size $r$ bits.
\tdi{padding}

The sponge hash function consist of the following components:
\begin{description}
\item[State memory $S = R ~||~ C$] \hfill \\
A vector of $b = r+c$ bits, where the first $r$ bits $R$ are used to input the message and output the digest and the remaining $c$ bits $C$ are internal and never exposed directly.
\item[Sponge function $f$] \hfill \\
A function $f: \{0,1\}^r\times\{0,1\}^c \to \{0,1\}^r\times\{0,1\}^c$ that permutes or otherwise transforms the state memory.
\end{description}

The hashing process then consists of two phases -- \emph{absorbing} and \emph{squeezing}.
First, we initialize $R_0 := 0^r$ and $C_0 := 0^c$. Then we define
\[
R_i, C_i = f(R_{i-1} \oplus x_i,~ C_{i-1})
\]

After $t$ rounds the entire message will be \emph{absorbed} into the state $S_t = R_t ~||~ C_t$.

To produce an output digest $y$ composed of $t'$ blocks $y_1, \dots, y_{t'}$ of length $r$ bits we will continue similarly:
\[
R_i, C_i = f(R_{i-1},~ C_{i-1})
\]
and the output will be $y_i = R_{t+i-1}$.
\tdi{Sponge security claims/proofs}

\subsubsection{SHA-3}
\tdi{sha3/keccak}


\tdi{Hash function attacks}
\tdi{Birthday attack}
\tdi{Other hash function attacks / attack types}

\tdi{Ciphers - AES}
\tdi{Cipher attacks}

\chapter{SAT}

\tdi{overview, NP complete}
\tdi{solvers}
\tdi{DPLL, CDCL}
\tdi{benchmarks, ...}
\tdi{extending, heuristics}

\chapter{Attacks}

\tdi{existing overview}
\tdi{details of few}
\tdi{Plans - partial preimage, ...}

\chapter{Encoding}

\tdi{existing tools}
\tdi{sha1 overview}
\tdi{goals}


\tdi{CITATIONS!!!}